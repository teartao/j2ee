[[cache-strategies]]
=== 了解抽象缓存
.缓存 vs 缓冲区
****

术语“缓冲区”和“缓存”倾向于可互换使用; 不过，它们代表不同的东西。传统上使用缓冲区作为快速和慢速实体之间的数据的中间临时存储。由于一方必须__等待__另一个影响性能的一方，所以缓冲区可以通过允许一次移动整个数据块而不是小块来缓解这一点。缓冲区的数据只写入和读取一次。此外，缓冲区对于至少一个知道它的一方是__可见__的。

另一方面，根据定义，缓存是隐藏的，双方都不知道存在缓存。它还通过允许以快速方式多次读取相同的数据提高了性能。

你可以
http://en.wikipedia.org/wiki/Cache_(computing)#The_difference_between_buffer_and_cache[在这里]
可以找到这两者差异的进一步解释 。
****

在其核心上，将抽象缓存应用于Java方法，从而减少基于缓存中可用信息的执行次数。也就是说，每次 调用__目标__方法时，检查给定参数的方法是否已经执行，如果已经执行，就不需要执行实际的方法，直接返回缓存的结果。如果没有执行，就会执行方法，并将结果缓存后返回给用户。当下次再调用该方法时，就可以直接返回缓存的结果。这样，对于给定的一组参数，昂贵的方法（无论是CPU或IO绑定）都可以执行一次。缓存逻辑被透明地应用，不会对调用者造成任何干扰。

[IMPORTANT]
====

显然，这种方法只适用于保证为给定输入（或参数）无论执行多少次都返回相同输出（结果）的方法。
====

其他缓存相关操作由抽象提供，例如更新缓存内容或删除所有条目之一的能力。这个功能对于处理过程中会发生变化的数据非常有用。

与 Spring Framework 中的其他服务一样，缓存服务是一种抽象（而不是缓存实现），并且需要使用实际的存储来存储缓存数据 - 也就是说，抽象使开发人员不必编写缓存逻辑但不提供实际的缓存存储。这种抽象是通过实现 `org.springframework.cache.Cache` 和
`org.springframework.cache.CacheManager`接口。

有几个实现开箱即用的缓存存储实现：基于 JDK `java.util.concurrent.ConcurrentMap` 的缓存， 
http://ehcache.org/[EhCache]，Gemfire 缓存，
https://code.google.com/p/guava-libraries/wiki/CachesExplained[Guava caches] 和
和JSR-107兼容的缓存。有关集成其他缓存的更多信息，请参见 <<cache-plug>>。

[IMPORTANT]
====
抽象缓存没有特殊处理多线程和多进程环境，因为这些功能由缓存实现来处理。
====

如果您有多进程环境（即部署在几个节点上的应用程序），则需要相应地配置缓存提供程序。根据使用情况，几个节点上相同数据的副本可能已经足够，但是如果在应用程序过程中更改数据，则可能需要启用另外的传播机制。

当多个线程同时更新或者驱逐数据时，有可能会使用过时的数据。有些缓存实现提供了一些可用的高级功能，你可以参考你使用的缓存实现了解更多信息。

要使用抽象缓存，开发人员需要注意两个方面：

* 缓存声明 - 识别需要缓存的方法及其策略
* 缓存配置 - 数据存储和读取的备份缓存


