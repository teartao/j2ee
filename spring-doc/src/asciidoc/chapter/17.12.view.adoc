[[views-form-macros-html-escaping]]
===== HTML escaping and XHTML compliance
Default usage of the form macros above will result in HTML tags that are HTML 4.01
compliant and that use the default value for HTML escaping defined in your web.xml as
used by Spring's bind support. In order to make the tags XHTML compliant or to override
the default HTML escaping value, you can specify two variables in your template (or in
your model where they will be visible to your templates). The advantage of specifying
them in the templates is that they can be changed to different values later in the
template processing to provide different behavior for different fields in your form.

To switch to XHTML compliance for your tags, specify a value of 'true' for a
model/context variable named xhtmlCompliant:

[source,jsp,indent=0]
[subs="verbatim,quotes"]
----
	## for Velocity..
	#set($springXhtmlCompliant = true)

	<#-- for FreeMarker -->
	<#assign xhtmlCompliant = true in spring>
----

Any tags generated by the Spring macros will now be XHTML compliant after processing
this directive.

In similar fashion, HTML escaping can be specified per field:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<#-- until this point, default HTML escaping is used -->

	<#assign htmlEscape = true in spring>
	<#-- next field will use HTML escaping -->
	<@spring.formInput "command.name" />

	<#assign htmlEscape = false in spring>
	<#-- all future fields will be bound with HTML escaping off -->
----




[[view-xslt]]
=== XSLT
XSLT is a transformation language for XML and is popular as a view technology within web
applications. XSLT can be a good choice as a view technology if your application
naturally deals with XML, or if your model can easily be converted to XML. The following
section shows how to produce an XML document as model data and have it transformed with
XSLT in a Spring Web MVC application.



[[view-xslt-firstwords]]
==== My First Words
This example is a trivial Spring application that creates a list of words in the
`Controller` and adds them to the model map. The map is returned along with the view
name of our XSLT view. See <<mvc-controller>> for details of Spring Web MVC's
`Controller` interface. The XSLT view will turn the list of words into a simple XML
document ready for transformation.


[[view-xslt-beandefs]]
===== Bean definitions
Configuration is standard for a simple Spring application. The dispatcher servlet config
file contains a reference to a `ViewResolver`, URL mappings and a single controller
bean...

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="homeController"class="xslt.HomeController"/>
----

... that encapsulates our word generation logic.


[[view-xslt-controllercode]]
===== Standard MVC controller code
The controller logic is encapsulated in a subclass of `AbstractController`, with the
handler method being defined like so...

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	protected ModelAndView handleRequestInternal(HttpServletRequest request,
			HttpServletResponse response) throws Exception {

		Map map = new HashMap();
		List wordList = new ArrayList();

		wordList.add("hello");
		wordList.add("world");

		map.put("wordList", wordList);

		return new ModelAndView("home", map);
	}
----

So far we've done nothing that's XSLT specific. The model data has been created in the
same way as you would for any other Spring MVC application. Depending on the
configuration of the application now, that list of words could be rendered by JSP/JSTL
by having them added as request attributes, or they could be handled by Velocity by
adding the object to the `VelocityContext`. In order to have XSLT render them, they of
course have to be converted into an XML document somehow. There are software packages
available that will automatically 'domify' an object graph, but within Spring, you have
complete flexibility to create the DOM from your model in any way you choose. This
prevents the transformation of XML playing too great a part in the structure of your
model data which is a danger when using tools to manage the domification process.


